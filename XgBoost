import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import xgboost as xgb
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler
import io
import base64

# Set page configuration
st.set_page_config(
    page_title="Bitcoin Price Analysis & Prediction",
    page_icon="ðŸ“ˆ",
    layout="wide"
)

# Helper functions
def calculate_rsi(data, periods=14):
    delta = data.diff()
    gains = delta.where(delta > 0, 0)
    losses = -delta.where(delta < 0, 0)
    avg_gains = gains.rolling(window=periods).mean()
    avg_losses = losses.rolling(window=periods).mean()
    rs = avg_gains / avg_losses
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data.ewm(span=short_window, adjust=False).mean()
    long_ema = data.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    return macd - signal

def calculate_bb(data, window=20, num_std=2):
    rolling_mean = data.rolling(window=window).mean()
    rolling_std = data.rolling(window=window).std()
    upper_band = rolling_mean + (rolling_std * num_std)
    lower_band = rolling_mean - (rolling_std * num_std)
    return upper_band, lower_band

def calculate_momentum(data, period=14):
    return data.diff(period)

def calculate_stochastic_oscillator(data, window=14):
    low_min = data.rolling(window=window).min()
    high_max = data.rolling(window=window).max()
    k = 100 * (data - low_min) / (high_max - low_min)
    return k

def calculate_roc(data, period=12):
    return ((data - data.shift(period)) / data.shift(period)) * 100

def run_xgboost_max_depth_tuning(X, y, progress_bar=None):
    # Parameter dasar
    base_params = {
        'objective': 'reg:squarederror',
        'learning_rate': 0.1,
        'subsample': 0.8,
        'colsample_bytree': 0.8,
        'random_state': 42,
        'n_estimators': 100
    }
    
    # Nilai max_depth yang akan dicoba
    max_depths = list(range(1, 11))  # 1 sampai 10
    
    # Persiapan hasil
    results = []
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    # K-Fold Cross Validation
    kf = KFold(n_splits=5, shuffle=True, random_state=42)
    
    # Ujicoba untuk setiap max_depth
    for i, depth in enumerate(max_depths):
        if progress_bar:
            progress_bar.progress((i + 1) / len(max_depths))
            
        params = base_params.copy()
        params['max_depth'] = depth
        
        rmse_values = []
        rmse_relatif_values = []
        
        for train_index, test_index in kf.split(X_scaled):
            X_train, X_test = X_scaled[train_index], X_scaled[test_index]
            y_train, y_test = y.iloc[train_index], y.iloc[test_index]
            
            model = xgb.XGBRegressor(**params)
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
            rmse_relatif = rmse / np.mean(y_test) * 100
            
            rmse_values.append(rmse)
            rmse_relatif_values.append(rmse_relatif)
        
        # Menyimpan hasil
        results.append({
            'max_depth': depth,
            'n_estimators': params['n_estimators'],
            'RMSE': np.mean(rmse_values),
            'RMSE_std': np.std(rmse_values),
            'RMSE_Relatif': np.mean(rmse_relatif_values),
            'RMSE_Relatif_std': np.std(rmse_relatif_values)
        })
    
    # Membuat DataFrame hasil
    results_df = pd.DataFrame(results)
    return results_df

def run_xgboost_n_estimators_tuning(X, y, best_max_depth, progress_bar=None):
    # Parameter dasar
    base_params = {
        'objective': 'reg:squarederror',
        'learning_rate': 0.1,
        'subsample': 0.8,
        'colsample_bytree': 0.8,
        'random_state': 42,
        'max_depth': best_max_depth
    }
    
    # Nilai n_estimators yang akan dicoba
    n_estimators_list = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
    
    # Persiapan hasil
    results = []
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    # K-Fold Cross Validation
    kf = KFold(n_splits=5, shuffle=True, random_state=42)
    
    # Ujicoba untuk setiap n_estimators
    for i, n_est in enumerate(n_estimators_list):
        if progress_bar:
            progress_bar.progress((i + 1) / len(n_estimators_list))
            
        params = base_params.copy()
        params['n_estimators'] = n_est
        
        rmse_values = []
        rmse_relatif_values = []
        
        for train_index, test_index in kf.split(X_scaled):
            X_train, X_test = X_scaled[train_index], X_scaled[test_index]
            y_train, y_test = y.iloc[train_index], y.iloc[test_index]
            
            model = xgb.XGBRegressor(**params)
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
            rmse_relatif = rmse / np.mean(y_test) * 100
            
            rmse_values.append(rmse)
            rmse_relatif_values.append(rmse_relatif)
        
        # Menyimpan hasil
        results.append({
            'max_depth': best_max_depth,
            'n_estimators': n_est,
            'RMSE': np.mean(rmse_values),
            'RMSE_std': np.std(rmse_values),
            'RMSE_Relatif': np.mean(rmse_relatif_values),
            'RMSE_Relatif_std': np.std(rmse_relatif_values)
        })
    
    # Membuat DataFrame hasil
    results_df = pd.DataFrame(results)
    return results_df

def get_download_link(df, filename, text):
    """Generates a link to download the CSV file of a dataframe"""
    csv = df.to_csv(index=False)
    b64 = base64.b64encode(csv.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="{filename}">{text}</a>'
    return href

def visualize_tuning_results(depth_results, estimators_results=None):
    # Plot hasil max_depth tuning
    fig1, axes1 = plt.subplots(1, 2, figsize=(12, 5))
    axes1[0].plot(depth_results['max_depth'], depth_results['RMSE'], marker='o')
    axes1[0].set_title('RMSE by max_depth')
    axes1[0].set_xlabel('max_depth')
    axes1[0].set_ylabel('RMSE')
    axes1[0].grid(True)
    
    axes1[1].plot(depth_results['max_depth'], depth_results['RMSE_Relatif'], marker='o', color='orange')
    axes1[1].set_title('RMSE Relatif (%) by max_depth')
    axes1[1].set_xlabel('max_depth')
    axes1[1].set_ylabel('RMSE Relatif (%)')
    axes1[1].grid(True)
    
    plt.tight_layout()
    st.pyplot(fig1)
    
    # Plot hasil n_estimators tuning jika tersedia
    if estimators_results is not None:
        fig2, axes2 = plt.subplots(1, 2, figsize=(12, 5))
        axes2[0].plot(estimators_results['n_estimators'], estimators_results['RMSE'], marker='o')
        axes2[0].set_title(f'RMSE by n_estimators (max_depth={estimators_results["max_depth"].iloc[0]})')
        axes2[0].set_xlabel('n_estimators')
        axes2[0].set_ylabel('RMSE')
        axes2[0].grid(True)
        
        axes2[1].plot(estimators_results['n_estimators'], estimators_results['RMSE_Relatif'], marker='o', color='orange')
        axes2[1].set_title(f'RMSE Relatif (%) by n_estimators (max_depth={estimators_results["max_depth"].iloc[0]})')
        axes2[1].set_xlabel('n_estimators')
        axes2[1].set_ylabel('RMSE Relatif (%)')
        axes2[1].grid(True)
        
        plt.tight_layout()
        st.pyplot(fig2)

def create_model_with_best_params(X, y, max_depth, n_estimators):
    """Membuat model XGBoost dengan parameter terbaik"""
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    model = xgb.XGBRegressor(
        objective='reg:squarederror',
        learning_rate=0.1,
        subsample=0.8,
        colsample_bytree=0.8,
        random_state=42,
        max_depth=max_depth,
        n_estimators=n_estimators
    )
    
    model.fit(X_scaled, y)
    return model, scaler

def plot_price_prediction(df, actual_prices, predicted_prices, start_idx):
    """Plot perbandingan harga aktual dan prediksi"""
    fig, ax = plt.subplots(figsize=(12, 6))
    
    dates = df.iloc[start_idx:]['Start'].values
    
    ax.plot(dates, actual_prices, label='Harga Aktual', color='blue')
    ax.plot(dates, predicted_prices, label='Prediksi', color='red', linestyle='--')
    
    ax.set_title('Perbandingan Harga Bitcoin Aktual vs Prediksi')
    ax.set_xlabel('Tanggal')
    ax.set_ylabel('Harga (USD)')
    ax.legend()
    ax.grid(True)
    
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    return fig

def plot_technical_indicators(df, window=30):
    """Plot indikator teknikal"""
    latest_data = df.iloc[-window:]
    
    # Plot Close price dan Moving Averages
    fig1, ax1 = plt.subplots(figsize=(12, 6))
    ax1.plot(latest_data['Start'], latest_data['Close'], label='Close Price', color='blue')
    ax1.plot(latest_data['Start'], latest_data['MA7'], label='MA7', color='orange')
    ax1.plot(latest_data['Start'], latest_data['MA21'], label='MA21', color='green')
    ax1.set_title('Harga Bitcoin dan Moving Averages')
    ax1.set_xlabel('Tanggal')
    ax1.set_ylabel('Harga (USD)')
    ax1.legend()
    ax1.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    # Plot RSI
    fig2, ax2 = plt.subplots(figsize=(12, 6))
    ax2.plot(latest_data['Start'], latest_data['RSI'], color='purple')
    ax2.axhline(y=70, color='r', linestyle='--', alpha=0.5)
    ax2.axhline(y=30, color='g', linestyle='--', alpha=0.5)
    ax2.set_title('RSI (Relative Strength Index)')
    ax2.set_xlabel('Tanggal')
    ax2.set_ylabel('RSI')
    ax2.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    # Plot MACD
    fig3, ax3 = plt.subplots(figsize=(12, 6))
    ax3.plot(latest_data['Start'], latest_data['MACD'], color='blue')
    ax3.axhline(y=0, color='r', linestyle='--', alpha=0.5)
    ax3.set_title('MACD')
    ax3.set_xlabel('Tanggal')
    ax3.set_ylabel('MACD')
    ax3.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    # Plot Bollinger Bands
    fig4, ax4 = plt.subplots(figsize=(12, 6))
    ax4.plot(latest_data['Start'], latest_data['Close'], label='Close Price', color='blue')
    ax4.plot(latest_data['Start'], latest_data['BB_Upper'], label='Upper Band', color='red', linestyle='--')
    ax4.plot(latest_data['Start'], latest_data['BB_Lower'], label='Lower Band', color='green', linestyle='--')
    ax4.set_title('Bollinger Bands')
    ax4.set_xlabel('Tanggal')
    ax4.set_ylabel('Harga (USD)')
    ax4.legend()
    ax4.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    return fig1, fig2, fig3, fig4

# Main Streamlit app
def main():
    st.title("Analisis dan Prediksi Harga Bitcoin")
    st.markdown("""
    Aplikasi ini memungkinkan Anda untuk menganalisis data historis Bitcoin, memvisualisasikan indikator teknikal,
    dan melatih model XGBoost untuk prediksi harga.
    """)
    
    # Sidebar for navigation
    st.sidebar.title("Navigasi")
    page = st.sidebar.radio("Pilih Halaman", ["Upload Data", "Analisis Data", "Hyperparameter Tuning", "Prediksi Harga"])
    
    # Initialize session state
    if 'df' not in st.session_state:
        st.session_state.df = None
    if 'depth_results' not in st.session_state:
        st.session_state.depth_results = None
    if 'estimators_results' not in st.session_state:
        st.session_state.estimators_results = None
    if 'best_max_depth' not in st.session_state:
        st.session_state.best_max_depth = None
    if 'best_n_estimators' not in st.session_state:
        st.session_state.best_n_estimators = None
    if 'model' not in st.session_state:
        st.session_state.model = None
    if 'scaler' not in st.session_state:
        st.session_state.scaler = None
        
    # Upload Data page
    if page == "Upload Data":
        st.header("Upload Data Bitcoin")
        
        uploaded_file = st.file_uploader("Upload CSV file Bitcoin", type=["csv"])
        
        if uploaded_file is not None:
            try:
                df = pd.read_csv(uploaded_file)
                
                # Check for required columns
                required_columns = ['Start', 'Open', 'High', 'Low', 'Close', 'Volume']
                missing_columns = [col for col in required_columns if col not in df.columns]
                
                if missing_columns:
                    st.error(f"File CSV tidak memiliki kolom yang diperlukan: {', '.join(missing_columns)}")
                    return
                
                # Konversi Start ke datetime
                df['Start'] = pd.to_datetime(df['Start'])
                
                # Hapus kolom 'Market Cap' jika ada
                if 'Market Cap' in df.columns:
                    df = df.drop(columns=['Market Cap'])
                
                # Menambah fitur teknikal
                with st.spinner('Menghitung indikator teknikal...'):
                    df['MA7'] = df['Close'].rolling(window=7).mean()
                    df['MA21'] = df['Close'].rolling(window=21).mean()
                    df['RSI'] = calculate_rsi(df['Close'])
                    df['MACD'] = calculate_macd(df['Close'])
                    df['BB_Upper'], df['BB_Lower'] = calculate_bb(df['Close'])
                    df['Momentum'] = calculate_momentum(df['Close'])
                    df['Stochastic'] = calculate_stochastic_oscillator(df['Close'])
                    df['ROC'] = calculate_roc(df['Close'])
                    df = df.dropna()
                
                # Save to session state
                st.session_state.df = df
                
                # Display sample data
                st.success(f"Data berhasil diupload! Total {len(df)} baris setelah menghapus missing values.")
                st.subheader("Sample Data")
                st.dataframe(df.head())
                
                # Display basic statistics
                st.subheader("Statistik Dasar - Harga Close")
                st.table(df['Close'].describe())
                
                # Plot harga historis
                st.subheader("Grafik Harga Historis Bitcoin")
                fig, ax = plt.subplots(figsize=(12, 6))
                ax.plot(df['Start'], df['Close'])
                ax.set_title('Harga Close Bitcoin')
                ax.set_xlabel('Tanggal')
                ax.set_ylabel('Harga (USD)')
                ax.grid(True)
                plt.xticks(rotation=45)
                plt.tight_layout()
                st.pyplot(fig)
                
            except Exception as e:
                st.error(f"Error dalam memproses file: {e}")
        
        else:
            st.info("Silakan upload file CSV data historis Bitcoin.")
    
    # Analisis Data page
    elif page == "Analisis Data":
        st.header("Analisis Data & Indikator Teknikal")
        
        if st.session_state.df is None:
            st.warning("Silakan upload data terlebih dahulu di halaman 'Upload Data'.")
            return
        
        df = st.session_state.df
        
        # Display time period selector
        st.subheader("Pilih Periode Waktu")
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input("Tanggal Mulai", value=df['Start'].min().date())
        with col2:
            end_date = st.date_input("Tanggal Akhir", value=df['Start'].max().date())
        
        # Filter data by date
        filtered_df = df[(df['Start'].dt.date >= start_date) & (df['Start'].dt.date <= end_date)]
        
        if len(filtered_df) == 0:
            st.warning("Tidak ada data dalam rentang waktu yang dipilih.")
            return
        
        st.success(f"Menampilkan data dari {start_date} hingga {end_date} ({len(filtered_df)} baris).")
        
        # Display technical indicators
        st.subheader("Indikator Teknikal")
        window = st.slider("Jumlah hari untuk ditampilkan", min_value=10, max_value=min(365, len(filtered_df)), value=30)
        
        # Plot indicators
        if window > len(filtered_df):
            window = len(filtered_df)
            
        fig1, fig2, fig3, fig4 = plot_technical_indicators(filtered_df, window)
        
        st.pyplot(fig1)
        st.pyplot(fig2)
        st.pyplot(fig3)
        st.pyplot(fig4)
        
        # Correlation heatmap
        st.subheader("Korelasi Antar Fitur")
        corr_cols = ['Open', 'High', 'Low', 'Close', 'Volume', 'MA7', 'MA21', 'RSI', 'MACD', 'Momentum', 'Stochastic', 'ROC']
        corr = filtered_df[corr_cols].corr()
        
        fig, ax = plt.subplots(figsize=(12, 10))
        im = ax.imshow(corr, cmap='coolwarm')
        
        # Add colorbar
        cbar = ax.figure.colorbar(im, ax=ax)
        
        # Set ticks
        ax.set_xticks(np.arange(len(corr_cols)))
        ax.set_yticks(np.arange(len(corr_cols)))
        ax.set_xticklabels(corr_cols, rotation=45, ha='right')
        ax.set_yticklabels(corr_cols)
        
        # Loop over data to add text annotations
        for i in range(len(corr_cols)):
            for j in range(len(corr_cols)):
                text = ax.text(j, i, f"{corr.iloc[i, j]:.2f}",
                               ha="center", va="center", color="black" if abs(corr.iloc[i, j]) < 0.5 else "white")
        
        ax.set_title("Korelasi Antar Fitur")
        fig.tight_layout()
        st.pyplot(fig)
    
    # Hyperparameter Tuning page
    elif page == "Hyperparameter Tuning":
        st.header("Hyperparameter Tuning Model XGBoost")
        
        if st.session_state.df is None:
            st.warning("Silakan upload data terlebih dahulu di halaman 'Upload Data'.")
            return
        
        df = st.session_state.df
        
        # Prepare features and target
        X = df[['Open', 'High', 'Low', 'Volume', 'MA7', 'MA21', 'RSI', 'MACD',
                'BB_Upper', 'BB_Lower', 'Momentum', 'Stochastic', 'ROC']]
        y = df['Close']
        
        st.subheader("Tuning Parameter max_depth")
        
        if st.session_state.depth_results is None:
            if st.button("Mulai Tuning max_depth"):
                with st.spinner('Melakukan tuning max_depth...'):
                    progress_bar = st.progress(0)
                    st.session_state.depth_results = run_xgboost_max_depth_tuning(X, y, progress_bar)
                    
                st.success("Tuning max_depth selesai!")
                
                # Determine best max_depth
                st.session_state.best_max_depth = int(st.session_state.depth_results.loc[
                    st.session_state.depth_results['RMSE'].idxmin(), 'max_depth'])
                
                st.write(f"Max depth terbaik: **{st.session_state.best_max_depth}**")
        else:
            st.success(f"Max depth terbaik: **{st.session_state.best_max_depth}**")
        
        # Display max_depth results if available
        if st.session_state.depth_results is not None:
            st.subheader("Hasil Tuning max_depth")
            st.dataframe(st.session_state.depth_results)
            
            # Download link for results
            st.markdown(get_download_link(st.session_state.depth_results, 
                                          'xgboost_max_depth_results.csv', 
                                          'Download hasil tuning max_depth (CSV)'), 
                        unsafe_allow_html=True)
            
            # Visualize results
            st.subheader("Visualisasi Hasil Tuning max_depth")
            visualize_tuning_results(st.session_state.depth_results)
            
            # Tuning n_estimators
            st.subheader("Tuning Parameter n_estimators")
            
            if st.session_state.estimators_results is None:
                if st.button("Mulai Tuning n_estimators"):
                    with st.spinner(f'Melakukan tuning n_estimators dengan max_depth={st.session_state.best_max_depth}...'):
                        progress_bar = st.progress(0)
                        st.session_state.estimators_results = run_xgboost_n_estimators_tuning(
                            X, y, st.session_state.best_max_depth, progress_bar)
                        
                    st.success("Tuning n_estimators selesai!")
                    
                    # Determine best n_estimators
                    st.session_state.best_n_estimators = int(st.session_state.estimators_results.loc[
                        st.session_state.estimators_results['RMSE'].idxmin(), 'n_estimators'])
                    
                    st.write(f"n_estimators terbaik: **{st.session_state.best_n_estimators}**")
                    
                    # Create best model
                    st.session_state.model, st.session_state.scaler = create_model_with_best_params(
                        X, y, st.session_state.best_max_depth, st.session_state.best_n_estimators)
            else:
                st.success(f"n_estimators terbaik: **{st.session_state.best_n_estimators}**")
        
        # Display n_estimators results if available
        if st.session_state.estimators_results is not None:
            st.subheader("Hasil Tuning n_estimators")
            st.dataframe(st.session_state.estimators_results)
            
            # Download link for results
            st.markdown(get_download_link(st.session_state.estimators_results, 
                                         'xgboost_n_estimators_results.csv', 
                                         'Download hasil tuning n_estimators (CSV)'), 
                       unsafe_allow_html=True)
            
            # Visualize results
            st.subheader("Visualisasi Hasil Tuning n_estimators")
            visualize_tuning_results(st.session_state.depth_results, st.session_state.estimators_results)
            
            # Best parameters summary
            st.subheader("Parameter Terbaik")
            best_row = st.session_state.estimators_results[
                st.session_state.estimators_results['n_estimators'] == st.session_state.best_n_estimators].iloc[0]
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric("max_depth", st.session_state.best_max_depth)
                st.metric("RMSE", f"{best_row['RMSE']:.3f} Â± {best_row['RMSE_std']:.3f}")
            
            with col2:
                st.metric("n_estimators", st.session_state.best_n_estimators)
                st.metric("RMSE Relatif", f"{best_row['RMSE_Relatif']:.2f}% Â± {best_row['RMSE_Relatif_std']:.2f}%")
    
    # Prediction page
    elif page == "Prediksi Harga":
        st.header("Prediksi Harga Bitcoin")
        
        if st.session_state.df is None:
            st.warning("Silakan upload data terlebih dahulu di halaman 'Upload Data'.")
            return
            
        if st.session_state.model is None:
            st.warning("Silakan lakukan hyperparameter tuning terlebih dahulu di halaman 'Hyperparameter Tuning'.")
            return
        
        df = st.session_state.df
        
        # Select test period
        st.subheader("Pilih Periode Pengujian")
        test_size = st.slider("Persentase data untuk pengujian (%)", 10, 30, 20)
        
        # Split data into train and test
        train_size = int(len(df) * (1 - test_size/100))
        train_df = df.iloc[:train_size]
        test_df = df.iloc[train_size:]
        
        st.write(f"Periode pelatihan: {train_df['Start'].min().date()} hingga {train_df['Start'].max().date()} ({len(train_df)} hari)")
        st.write(f"Periode pengujian: {test_df['Start'].min().date()} hingga {test_df['Start'].max().date()} ({len(test_df)} hari)")
        
        # Prepare features
        X_test = test_df[['Open', 'High', 'Low', 'Volume', 'MA7', 'MA21', 'RSI', 'MACD',
                         'BB_Upper', 'BB_Lower', 'Momentum', 'Stochastic', 'ROC']]
        
        # Make predictions
        if st.button("Buat Prediksi"):
            with st.spinner("Membuat prediksi..."):
                # Scale test features
                X_test_scaled = st.session_state.scaler.transform(X_test)
                
                # Make predictions
                y_pred = st.session_state.model.predict(X_test_scaled)
                
                # Calculate RMSE
                rmse = np.sqrt(mean_squared_error(test_df['Close'], y_pred))
                rmse_relatif = rmse / np.mean(test_df['Close']) * 100
                
                # Display metrics
                st.subheader("Hasil Prediksi")
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("RMSE", f"{rmse:.2f}")
                with col2:
                    st.metric("RMSE Relatif", f"{rmse_relatif:.2f}%")
                    
                # Plot predictions vs actual
                st.subheader("Grafik Prediksi vs Aktual")
                fig = plot_price_prediction(df, test_df['Close'].values, y_pred, train_size)
                st.pyplot(fig)
                
                # Feature importance
                st.subheader("Feature Importance")
                feature_importance = pd.DataFrame({
                    'Feature': X_test.columns,
                    'Importance': st.session_state.model.feature_importances_
                }).sort_values('Importance', ascending=False)
                
                fig, ax = plt.subplots(figsize=(10, 6))
                ax.barh(feature_importance['Feature'], feature_importance['Importance'])
                ax.set_title('Feature Importance')
                ax.set_xlabel('Importance')
                ax.invert_yaxis()  # Highest at the top
                plt.tight_layout()
                st.pyplot(fig)
                
                # Show predictions as table
                st.subheader("Tabel Prediksi")
                
                prediction_df = pd.DataFrame({
                    'Tanggal': test_df['Start'],
                    'Harga Aktual': test_df['Close'],
                    'Prediksi': y_pred,
                    'Selisih': test_df['Close'] - y_pred,
                    'Selisih (%)': ((test_df['Close'] - y_pred) / test_df['Close']) * 100
                })
                
                st.dataframe(prediction_df)
                
                # Download link for predictions
                st.markdown(get_download_link(prediction_df, 
                                            'bitcoin_predictions.csv', 
                                            'Download hasil prediksi (CSV)'), 
                        unsafe_allow_html=True)
        
        # Forecast future prices
        st.subheader("Prediksi Harga Masa Depan")
        st.write("Gunakan data terakhir untuk memprediksi harga di masa depan:")
        
        days_to_predict = st.slider("Jumlah hari untuk diprediksi", 1, 30, 7)
        
        if st.button("Buat Prediksi Masa Depan"):
            with st.spinner("Membuat prediksi masa depan..."):
                # Get the last available data point
                last_data = df.iloc[-1:].copy()
                last_date = last_data['Start'].iloc[0]
                
                # Create a future dataframe
                future_dates = [last_date + pd.Timedelta(days=i+1) for i in range(days_to_predict)]
                future_df = pd.DataFrame({'Start': future_dates})
                
                # Initialize with last values
                future_predictions = []
                current_data = last_data.copy()
                
                for i in range(days_to_predict):
                    # Prepare features
                    X_pred = current_data[['Open', 'High', 'Low', 'Volume', 'MA7', 'MA21', 'RSI', 'MACD',
                                        'BB_Upper', 'BB_Lower', 'Momentum', 'Stochastic', 'ROC']]
                    
                    # Scale features
                    X_pred_scaled = st.session_state.scaler.transform(X_pred)
                    
                    # Predict
                    pred = st.session_state.model.predict(X_pred_scaled)[0]
                    future_predictions.append(pred)
                    
                    # Create next day data (simple approach assuming Open=Close of previous day)
                    next_data = current_data.copy()
                    next_data['Start'] = future_dates[i]
                    next_data['Open'] = pred
                    next_data['Close'] = pred  # Simplified
                    next_data['High'] = pred * 1.01  # Simplified
                    next_data['Low'] = pred * 0.99  # Simplified
                    next_data['Volume'] = current_data['Volume'].values[0]  # Simplified
                    
                    # Update technical indicators
                    # This is simplified - in a real scenario we would calculate these based on historical data
                    next_data['MA7'] = (current_data['MA7'].values[0] * 6 + pred) / 7
                    next_data['MA21'] = (current_data['MA21'].values[0] * 20 + pred) / 21
                    next_data['RSI'] = current_data['RSI'].values[0]  # Simplified
                    next_data['MACD'] = current_data['MACD'].values[0]  # Simplified
                    next_data['BB_Upper'] = current_data['BB_Upper'].values[0]  # Simplified
                    next_data['BB_Lower'] = current_data['BB_Lower'].values[0]  # Simplified
                    next_data['Momentum'] = current_data['Momentum'].values[0]  # Simplified
                    next_data['Stochastic'] = current_data['Stochastic'].values[0]  # Simplified
                    next_data['ROC'] = current_data['ROC'].values[0]  # Simplified
                    
                    # Update current data for next iteration
                    current_data = next_data.copy()
                
                # Display future predictions
                future_df['Prediksi Harga'] = future_predictions
                
                st.subheader("Hasil Prediksi Masa Depan")
                st.dataframe(future_df)
                
                # Plot future predictions
                fig, ax = plt.subplots(figsize=(12, 6))
                
                # Plot historical data (last 30 days)
                historical_window = min(30, len(df))
                historical_df = df.iloc[-historical_window:]
                ax.plot(historical_df['Start'], historical_df['Close'], label='Data Historis', color='blue')
                
                # Plot predictions
                ax.plot(future_df['Start'], future_df['Prediksi Harga'], label='Prediksi', color='red', linestyle='--')
                
                # Add vertical line to separate historical and prediction
                ax.axvline(x=last_date, color='green', linestyle='-.')
                
                ax.set_title('Prediksi Harga Bitcoin Masa Depan')
                ax.set_xlabel('Tanggal')
                ax.set_ylabel('Harga (USD)')
                ax.legend()
                ax.grid(True)
                
                plt.xticks(rotation=45)
                plt.tight_layout()
                st.pyplot(fig)
                
                # Download link for future predictions
                st.markdown(get_download_link(future_df, 
                                            'bitcoin_future_predictions.csv', 
                                            'Download prediksi masa depan (CSV)'), 
                          unsafe_allow_html=True)
                
                # Warning message
                st.warning("""
                **Catatan:** Prediksi masa depan ini bersifat estimasi dan menggunakan pendekatan yang disederhanakan.
                Faktor-faktor eksternal seperti berita, regulasi, dan sentimen pasar tidak dipertimbangkan dalam model ini.
                Gunakan prediksi ini hanya sebagai referensi, bukan rekomendasi investasi.
                """)

if __name__ == "__main__":
    main()
