import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.feature_selection import f_regression
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error
import itertools
import warnings
import base64
from io import BytesIO

# Nonaktifkan warning yang tidak perlu
warnings.filterwarnings('ignore')

# Set page configuration
st.set_page_config(
    page_title="Bitcoin Price Prediction",
    page_icon="📈",
    layout="wide"
)

# Functions from the original script
def calculate_rsi(data, periods=14):
    # Menghitung perubahan harga
    delta = data.diff()
    
    # Mendapatkan gains dan losses
    gains = delta.where(delta > 0, 0)
    losses = -delta.where(delta < 0, 0)
    
    # Menghitung average gains dan losses
    avg_gains = gains.rolling(window=periods).mean()
    avg_losses = losses.rolling(window=periods).mean()
    
    # Menghitung RS dan RSI
    rs = avg_gains / avg_losses
    rsi = 100 - (100 / (1 + rs))
    
    return rsi

def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    # Menghitung EMA
    short_ema = data.ewm(span=short_window, adjust=False).mean()
    long_ema = data.ewm(span=long_window, adjust=False).mean()
    
    # Menghitung MACD dan Signal line
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    
    return macd - signal

def calculate_bb(data, window=20, num_std=2):
    """Bollinger Bands"""
    rolling_mean = data.rolling(window=window).mean()
    rolling_std = data.rolling(window=window).std()
    upper_band = rolling_mean + (rolling_std * num_std)
    lower_band = rolling_mean - (rolling_std * num_std)
    return upper_band, lower_band

def calculate_momentum(data, period=14):
    """Momentum Indicator"""
    return data.diff(period)

def calculate_stochastic_oscillator(data, window=14):
    """Stochastic Oscillator"""
    low_min = data.rolling(window=window).min()
    high_max = data.rolling(window=window).max()
    k = 100 * (data - low_min) / (high_max - low_min)
    return k

def calculate_roc(data, period=12):
    """Rate of Change"""
    return ((data - data.shift(period)) / data.shift(period)) * 100

def calculate_metrics(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    rmse_relatif = rmse / np.mean(y_true) * 100
    return rmse, rmse_relatif

def eliminate_collinear_features(X, threshold=0.85):
    correlation_matrix = X.corr().abs()
    upper = correlation_matrix.where(np.triu(np.ones(correlation_matrix.shape), k=1).astype(bool))
    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]
    
    X_reduced = X.drop(columns=to_drop)
    return X_reduced, to_drop

def feature_selection_none(X, y):
    return X

def feature_selection_m5_prime(X, y):
    # M5 Prime dengan F-Regression
    f_scores, _ = f_regression(X, y)
    feature_scores = pd.Series(f_scores, index=X.columns)
    selected_features = feature_scores.nlargest(3).index.tolist()
    return X[selected_features]

def feature_selection_greedy(X, y, threshold=0.01):
    selected_features = []
    remaining_features = list(X.columns)
    current_score = float('inf')
    
    log_messages = []
    log_messages.append("Proses Greedy Feature Selection:")
    
    while remaining_features:
        scores = []
        for feature in remaining_features:
            test_features = selected_features + [feature]
            X_subset = X[test_features]
            
            kf = KFold(n_splits=5, shuffle=True, random_state=42)
            rmse_values = []
            
            for train_idx, val_idx in kf.split(X_subset):
                X_train, X_val = X_subset.iloc[train_idx], X_subset.iloc[val_idx]
                y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]
                
                model = LinearRegression()
                model.fit(X_train, y_train)
                y_pred = model.predict(X_val)
                rmse = np.sqrt(mean_squared_error(y_val, y_pred))
                rmse_values.append(rmse)
            
            mean_rmse = np.mean(rmse_values)
            scores.append((feature, mean_rmse))
        
        # Pilih fitur terbaik
        best_feature, best_score = min(scores, key=lambda x: x[1])
        
        if best_score < current_score:
            current_score = best_score
            selected_features.append(best_feature)
            remaining_features.remove(best_feature)
            log_messages.append(f"Menambahkan fitur: {best_feature}, RMSE: {best_score:.3f}")
        else:
            break
    
    log_messages.append(f"Fitur yang dipilih oleh Greedy: {selected_features}")
    return X[selected_features], log_messages

def feature_selection_ttest(X, y):
    # T-Test dengan F-Regression
    f_scores, p_values = f_regression(X, y)
    # Pilih fitur dengan p-value signifikan (< 0.05)
    significant_features = X.columns[p_values < 0.00000002]
    return X[significant_features]

def feature_selection_iterative_ttest(X, y):
    selected_features = []
    remaining_features = list(X.columns)
    
    log_messages = []
    log_messages.append("Proses Iterative T-Test Feature Selection:")
    
    while remaining_features:
        f_scores, p_values = f_regression(X[remaining_features], y)
        feature_pvalues = pd.Series(p_values, index=remaining_features)
        
        # Pilih fitur dengan p-value terkecil
        best_feature = feature_pvalues.idxmin()
        
        if feature_pvalues[best_feature] < 0.05:
            selected_features.append(best_feature)
            remaining_features.remove(best_feature)
            log_messages.append(f"Menambahkan fitur: {best_feature}, p-value: {feature_pvalues[best_feature]:.8f}")
        else:
            break
    
    log_messages.append(f"Fitur yang dipilih oleh Iterative T-Test: {selected_features}")
    return X[selected_features], log_messages

def get_figure_as_base64(fig):
    buf = BytesIO()
    fig.savefig(buf, format="png", dpi=300, bbox_inches='tight')
    buf.seek(0)
    img_str = base64.b64encode(buf.read()).decode()
    return img_str

def plot_comparison_predictions_and_errors(df, X, y, feature_selection_methods):
    # Membuat figure dengan 2 subplot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 12))
    
    # Colors untuk setiap metode
    colors = {
        'none': 'blue',
        'greedy': 'red',
        'ttest': 'green',
        'm5_prime': 'purple',
        'iterative_ttest': 'orange'
    }
    
    # Plot aktual di kedua subplot
    ax1.plot(df['Start'], y, label='Actual Price', color='black', linewidth=2)
    
    # Dictionary untuk menyimpan predictions dan errors
    predictions = {}
    errors = {}
    
    # Proses setiap metode
    for method_name in feature_selection_methods:
        if method_name == 'none':
            X_selected = feature_selection_none(X, y)
        elif method_name == 'greedy':
            X_selected, _ = feature_selection_greedy(X, y)
        elif method_name == 'ttest':
            X_selected = feature_selection_ttest(X, y)
        elif method_name == 'm5_prime':
            X_selected = feature_selection_m5_prime(X, y)
        else:  # iterative_ttest
            X_selected, _ = feature_selection_iterative_ttest(X, y)
        
        # Fit model dan predict
        model = LinearRegression().fit(X_selected, y)
        y_pred = model.predict(X_selected)
        predictions[method_name] = y_pred
        errors[method_name] = y - y_pred
        
        # Plot predictions
        ax1.plot(df['Start'], y_pred, 
                label=f'Predicted ({method_name})', 
                color=colors[method_name], alpha=0.7)
        
        # Plot errors
        ax2.plot(df['Start'], errors[method_name], 
                label=f'Error ({method_name})', 
                color=colors[method_name], alpha=0.7)
    
    # Konfigurasi subplot prediksi
    ax1.set_title('Actual vs Predicted Bitcoin Price', fontsize=14)
    ax1.set_xlabel('Date', fontsize=12)
    ax1.set_ylabel('Price (USD)', fontsize=12)
    ax1.legend()
    ax1.grid(True)
    
    # Konfigurasi subplot error
    ax2.axhline(y=0, color='black', linestyle='--')
    ax2.set_title('Prediction Errors Over Time', fontsize=14)
    ax2.set_xlabel('Date', fontsize=12)
    ax2.set_ylabel('Error (USD)', fontsize=12)
    ax2.legend()
    ax2.grid(True)
    
    plt.tight_layout()
    return fig

def plot_prediction_vs_actual(X, y, model, method_name, df):
    y_pred = model.predict(X)
    
    fig = plt.figure(figsize=(12, 6))
    plt.plot(df['Start'], y, label='Actual Price', color='blue')
    plt.plot(df['Start'], y_pred, label='Predicted Price', color='red')
    plt.title(f'Actual vs Predicted Bitcoin Price ({method_name})', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Price (USD)', fontsize=12)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    return fig

def plot_prediction_error(X, y, model, method_name, df):
    y_pred = model.predict(X)
    errors = y - y_pred
    
    fig = plt.figure(figsize=(12, 6))
    plt.plot(df['Start'], errors, color='red')
    plt.axhline(y=0, color='black', linestyle='--')
    plt.title(f'Prediction Error Over Time ({method_name})', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Error (USD)', fontsize=12)
    plt.grid(True)
    plt.tight_layout()
    return fig

def visualize_results(results_df):
    # Membuat figure
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
    
    # Plot untuk RMSE
    colors = ['lightblue', 'lightgreen']
    sns.barplot(data=results_df, 
                x='Metode Seleksi Fitur', 
                y='RMSE Rata-rata',
                hue='Collinearity',
                palette=colors,
                ax=ax1)
    ax1.set_title('Perbandingan RMSE untuk Setiap Metode', fontsize=14, pad=20)
    ax1.set_ylabel('RMSE', fontsize=12)
    ax1.tick_params(axis='x', rotation=45)
    
    # Plot untuk RMSE Relatif
    sns.barplot(data=results_df, 
                x='Metode Seleksi Fitur', 
                y='RMSE Relatif Rata-rata',
                hue='Collinearity',
                palette=colors,
                ax=ax2)
    ax2.set_title('Perbandingan RMSE Relatif untuk Setiap Metode', fontsize=14, pad=20)
    ax2.set_ylabel('RMSE Relatif (%)', fontsize=12)
    ax2.tick_params(axis='x', rotation=45)
    
    # Mengatur layout
    plt.tight_layout()
    return fig

def run_experiments(X, y, df, selected_feature_methods, use_collinearity, threshold=0.85):
    # Mapping metode seleksi fitur ke fungsi
    feature_selection_method_map = {
        'none': feature_selection_none,
        'm5_prime': feature_selection_m5_prime,
        'greedy': feature_selection_greedy,
        'ttest': feature_selection_ttest,
        'iterative_ttest': feature_selection_iterative_ttest
    }
    
    results = []
    
    # Proses data
    X_processed = X.copy()
    if use_collinearity:
        X_processed, dropped_features = eliminate_collinear_features(X_processed, threshold)
    else:
        dropped_features = []
    
    for method_name in selected_feature_methods:
        # Seleksi fitur
        if method_name in ['greedy', 'iterative_ttest']:
            X_selected, log_messages = feature_selection_method_map[method_name](X_processed, y)
        else:
            X_selected = feature_selection_method_map[method_name](X_processed, y)
            log_messages = []
        
        # Cross-validation
        kf = KFold(n_splits=5, shuffle=True, random_state=42)
        rmse_values = []
        rmse_relatif_values = []
        
        for train_index, test_index in kf.split(X_selected):
            X_train, X_test = X_selected.iloc[train_index], X_selected.iloc[test_index]
            y_train, y_test = y.iloc[train_index], y.iloc[test_index]
            
            model = LinearRegression()
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            
            rmse, rmse_relatif = calculate_metrics(y_test, y_pred)
            rmse_values.append(rmse)
            rmse_relatif_values.append(rmse_relatif)
        
        # Melatih model dengan semua data untuk visualisasi
        final_model = LinearRegression()
        final_model.fit(X_selected, y)
        
        # Simpan hasil
        results.append({
            'Collinearity': 'Ya' if use_collinearity else 'Tidak',
            'Metode Seleksi Fitur': method_name,
            'Fitur Terpilih': list(X_selected.columns),
            'RMSE Rata-rata': np.mean(rmse_values),
            'Std RMSE': np.std(rmse_values),
            'RMSE Relatif Rata-rata': np.mean(rmse_relatif_values),
            'Std RMSE Relatif': np.std(rmse_relatif_values),
            'Log Messages': log_messages,
            'Model': final_model,
            'X_selected': X_selected
        })
    
    # Tampilkan hasil
    results_df = pd.DataFrame([{k: v for k, v in result.items() if k not in ['Log Messages', 'Model', 'X_selected']} 
                              for result in results])
    
    return results_df, results

def main():
    st.title("📊 Bitcoin Price Prediction with Linear Regression")
    st.markdown("""
    Aplikasi ini menganalisis harga Bitcoin menggunakan Linear Regression dengan berbagai metode seleksi fitur.
    Upload file CSV harga Bitcoin Anda atau gunakan dataset contoh untuk mulai menganalisis.
    """)
    
    # Sidebar for uploading files and configuration
    st.sidebar.header("⚙️ Konfigurasi")
    
    # File upload
    uploaded_file = st.sidebar.file_uploader("Upload CSV Bitcoin Data", type=['csv'])
    
    if uploaded_file is not None:
        df = pd.read_csv(uploaded_file)
    else:
        st.sidebar.info("Mohon upload file CSV data Bitcoin")
        # Create empty dataframe for placeholder
        df = pd.DataFrame()
        
    # Only proceed if data is available
    if not df.empty:
        # Convert date
        try:
            df['Start'] = pd.to_datetime(df['Start'])
        except:
            st.error("CSV harus memiliki kolom 'Start' yang berisi tanggal")
            st.stop()
        
        # Check for required columns
        required_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            st.error(f"Kolom yang diperlukan tidak ditemukan: {', '.join(missing_columns)}")
            st.stop()
        
        # Drop Market Cap if exists
        if 'Market Cap' in df.columns:
            df = df.drop(columns=['Market Cap'])
            
        # Show data preview
        st.subheader("Preview Dataset")
        st.dataframe(df.head())
        
        # Configuration options
        st.sidebar.subheader("Opsi Analisis")
        
        # Feature selection methods
        st.sidebar.subheader("Metode Seleksi Fitur")
        feature_methods = {
            'none': 'Tanpa Seleksi Fitur',
            'm5_prime': 'M5 Prime (Top 3 fitur)',
            'greedy': 'Greedy Selection',
            'ttest': 'T-Test',
            'iterative_ttest': 'Iterative T-Test'
        }
        
        selected_methods = []
        for method_key, method_name in feature_methods.items():
            if st.sidebar.checkbox(method_name, value=(method_key == 'none')):
                selected_methods.append(method_key)
        
        # Collinearity options
        st.sidebar.subheader("Eliminasi Kolinearitas")
        use_collinearity = st.sidebar.checkbox("Gunakan Eliminasi Kolinearitas", value=False)
        collinearity_threshold = st.sidebar.slider("Threshold Kolinearitas", 0.5, 0.99, 0.85, 0.01)
        
        # Run analysis button
        if st.sidebar.button("Jalankan Analisis"):
            # Show spinner while processing
            with st.spinner('Memproses data dan menjalankan analisis...'):
                # Menambah fitur teknikal
                progress_bar = st.progress(0)
                
                st.subheader("Menghitung Indikator Teknikal...")
                df['MA7'] = df['Close'].rolling(window=7).mean()
                progress_bar.progress(10)
                
                df['MA21'] = df['Close'].rolling(window=21).mean()
                progress_bar.progress(20)
                
                df['RSI'] = calculate_rsi(df['Close'])
                progress_bar.progress(30)
                
                df['MACD'] = calculate_macd(df['Close'])
                progress_bar.progress(40)
                
                df['BB_Upper'], df['BB_Lower'] = calculate_bb(df['Close'])
                progress_bar.progress(50)
                
                df['Momentum'] = calculate_momentum(df['Close'])
                progress_bar.progress(60)
                
                df['Stochastic'] = calculate_stochastic_oscillator(df['Close'])
                progress_bar.progress(70)
                
                df['ROC'] = calculate_roc(df['Close'])
                progress_bar.progress(80)
                
                df = df.dropna()
                
                # Memisahkan fitur dan target
                X = df[['Open', 'High', 'Low', 'Volume', 'MA7', 'MA21', 
                         'RSI', 'MACD', 'BB_Upper', 'BB_Lower', 
                         'Momentum', 'Stochastic', 'ROC']]
                y = df['Close']
                
                progress_bar.progress(90)
                
                # Tampilkan matriks korelasi
                st.subheader("Matriks Korelasi")
                fig, ax = plt.subplots(figsize=(12, 10))
                corr_matrix = X.corr()
                sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5, ax=ax)
                st.pyplot(fig)
                
                # Jalankan eksperimen
                results_df, full_results = run_experiments(
                    X, y, df, 
                    selected_methods, 
                    use_collinearity, 
                    collinearity_threshold
                )
                
                progress_bar.progress(100)
                
                # Tampilkan hasil dalam tabel
                st.subheader("Hasil Analisis")
                st.dataframe(results_df.style.highlight_min(subset=['RMSE Rata-rata']))
                
                # Visualisasi hasil
                st.subheader("Perbandingan Metode Seleksi Fitur")
                fig_results = visualize_results(results_df)
                st.pyplot(fig_results)
                
                # Tampilkan detail setiap metode
                st.subheader("Detail Hasil Setiap Metode")
                
                for result in full_results:
                    method_name = result['Metode Seleksi Fitur']
                    collinearity = result['Collinearity']
                    
                    with st.expander(f"Metode: {method_name} (Collinearity: {collinearity})"):
                        st.write(f"**Fitur Terpilih:** {', '.join(result['Fitur Terpilih'])}")
                        st.write(f"**RMSE Rata-rata:** {result['RMSE Rata-rata']:.2f}")
                        st.write(f"**RMSE Relatif Rata-rata:** {result['RMSE Relatif Rata-rata']:.2f}%")
                        
                        # Display logs if available
                        if 'Log Messages' in result and result['Log Messages']:
                            st.subheader("Log Seleksi Fitur")
                            for msg in result['Log Messages']:
                                st.write(msg)
                        
                        # Plot prediction vs actual
                        st.subheader("Prediksi vs Aktual")
                        fig_pred = plot_prediction_vs_actual(
                            result['X_selected'], y, result['Model'], 
                            method_name, df
                        )
                        st.pyplot(fig_pred)
                        
                        # Plot error
                        st.subheader("Grafik Error")
                        fig_error = plot_prediction_error(
                            result['X_selected'], y, result['Model'], 
                            method_name, df
                        )
                        st.pyplot(fig_error)
                
                # Comparison plot
                st.subheader("Perbandingan Semua Metode")
                comparison_fig = plot_comparison_predictions_and_errors(df, X, y, selected_methods)
                st.pyplot(comparison_fig)
                
                # Download hasil sebagai CSV
                csv = results_df.to_csv(index=False)
                b64 = base64.b64encode(csv.encode()).decode()
                href = f'<a href="data:file/csv;base64,{b64}" download="bitcoin_prediction_results.csv">Download Hasil Analisis (CSV)</a>'
                st.markdown(href, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
